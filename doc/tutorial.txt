= BioScala Tutorial =

''Copyright (C) 2010, Pjotr Prins''

== Introduction ==

The goal of the BioScala project is to create a scalable and functional
bioinformatics library, building on existing libraries available on the JAVA
Virtual Machine (JVM) - including BioJAVA and BioRuby.

To try BioScala ascertain the bioscala.jar and biojava.jar are in the class
path (jruby-complete-1.5.0.RC1.jar and scalatest-1.0.jar are optional). For
example:

  scala -cp bioscala.jar:biojava.jar

Fires up the scala interpreter:

  Welcome to Scala version 2.7.7 final 
  scala> _

Next import BioScala

  scala> import bio._

and create a Sequence object

  scala> val dna = new DNA.Sequence("agctaacg")
  seq: bio.DNA.Sequence = agctaacg 

== Working with Sequences ==

Sequence is strongly typed. Creating a DNA sequence from and RNA string will
give an error

  scala> val dna2 = new DNA.Sequence("agcuaacg")
  java.lang.IllegalArgumentException: Unexpected value for nucleotide u

You can transcribe DNA

  scala> val rna = dna.transcribe    
  rna: bio.RNA.Sequence = agcuaacg

Notice it is an RNA object now. Nucleotides are proper lists.

  val l = RNA.A :: rna.toList
  l: List[bio.Nucleotide] = List(a, a, g, c, u, a, a, c, g)
 
to translate nucleotides to amino acids:

  scala> SequenceTranslation.translate(l)
  res3: String = KLT

== Using BioJAVA from Scala ==

One of the great features of Scala is that it runs on the JAVA virtual
machine and creates JAVA byte code. In effect, the generated byte code
is equal to that of JAVA generated byte code. This means you can
deploy Scala with JAVA, and you can interact between the two
languages. An example is in BioScala's Sequence translation, from
./src/main/scala/sequence/translate.scala

  import org.biojava.bio.symbol._
  import org.biojava.bio.seq._
  import bio._

  package bio {
    object SequenceTranslation {
      /** 
       * Translate nucleotides to amini acids (will change to returning List)
       */
      def translate(nucleotides: List[Nucleotide]): String = {
        val rna = RNATools.createRNA(nucleotides.mkString);
        val aa = RNATools.translate(rna);
        aa.seqString
      }
    }
  }

You can see we import BioJAVA classes, and call directly into
BioJAVA's RNATools to create an RNA object, followed by translation
to an amino acid string.

== Using BioRuby from Scala ==

BioRuby compiles against JRuby on the JAVA Virtual Machine. Like, the
description above, on BioJAVA, we can call directly into compiled Ruby byte
code. For a BioRuby translation example, create a Ruby class like:

  require 'java'
  require 'bio'

  class RbSequence
    def translate(sequence, frame, codon_table)
      seq = Bio::Sequence::NA.new(sequence)
      seq.translate(frame,codon_table)
    end
  end

After compiling above with jrubyc it can be invoked from Scala

  scala> val rbseq = new RbSequence
  scala> rbseq.translate("agtcat",1,1)

assuming you have the jruby-complete.jar file in the class path and BioRuby
installed.







