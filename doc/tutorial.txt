= BioScala Tutorial =

''Copyright (C) 2010, Pjotr Prins''

== Introduction ==

The goal of the BioScala project is to create a scalable and functional
bioinformatics library, building on existing libraries available on the JAVA
Virtual Machine (JVM) - including BioJAVA and BioRuby.

To try BioScala ascertain the bioscala.jar and biojava.jar are in the class
path (jruby-complete-1.5.0.RC1.jar and scalatest-1.0.jar are optional). For
example:

  scala -cp bioscala.jar:biojava.jar

Fires up the scala interpreter:

  Welcome to Scala version 2.7.7 final 
  scala> _

Next import BioScala

  scala> import bio._

and create a Sequence object

  scala> val dna = new DNA.Sequence("agctaacg")
  seq: bio.DNA.Sequence = agctaacg 

== Working with Sequences ==

Sequence is strongly typed. Creating a DNA sequence from and RNA string will
give an error

  scala> val dna2 = new DNA.Sequence("agcuaacg")
  java.lang.IllegalArgumentException: Unexpected value for nucleotide u

You can transcribe DNA

  scala> val rna = dna.transcribe    
  rna: bio.RNA.Sequence = agcuaacg

Notice it is an RNA object now. Nucleotides are proper lists.

  val l = RNA.A :: rna.toList
  l: List[bio.Nucleotide] = List(a, a, g, c, u, a, a, c, g)
 
to translate nucleotides to amino acids:

  scala> SequenceTranslation.translate(l)
  res3: String = KLT

Create a Sequence with ID

  scala> val seq = new DNA.Sequence("ID456","agctaacg")
  scala> seq.id
  String = ID456
   
ID and description

  scala> val seq = new DNA.Sequence("ID456","My gene", "agctaacg")
  scala> seq.description
  String = My gene

A Sequence, like in the real world, can have multiple ID's and
descriptions. 

  scala> import bio.attribute._
  scala> val seq2 = seq.attrAdd(Id("Pubmed:456"))
  scala> seq2.idList
  List[bio.Attribute] = List(Pubmed:456, ID456)

  scala> val seq3 = seq2.attrAdd(Description("Another description")) 
  scala> seq3.descriptionList
  List[bio.Attribute] = List(Another description, My gene)

Note that Sequence is immutable. Every time you add an attribute a new
copy gets created.

== Sequence Attributes ==

BioScala allows you to add any attribute to a Sequence object. You
can even define your own attributes. Predefined attributes are one
or more id's, descriptions, annotations, features, gaps etc.

BioScala uses a message paradigm to access the list of attributes.
This way an attribute can 'decide' to respond to a message. This also
allows unanticipated usage of the Sequence object. Anyone can create
special attributes that react to special messages.

One example is that the BioScala Description attribute responds to
the GetXML message. If you check the source code - it is not part of
the core Sequence implementation, but part of the Description
attribute(!) We can generate XML:

    "Description Attribute" should "respond to GetXML" in {
      val descr = new Description("Some desription")
      val msg = descr.send(GetXML) 
      msg should equal (Ok,"<Description>Some description</Description>")
    }

Do turn a Sequence into XML we can do

  scala> val seq = new DNA.Sequence("ID356","Describe gene 356","agctgaatc")

First we filter on attributes that understand the messsage GetXML

  scala> val xml = seq.attribValues(GetXML,seq.attributes)

Next we generate output

  scala> xml.mkString should equal ("<Id>ID456</Id><Description>Gene 456</Description>")

Again, the Sequence object did not need to understand XML to achieve this.
Only the Id and Description objects understand to interpret the GetXML message.

You can add *any* type of Attribute to a Sequence object.

== Alignment ==

Alignment is a container for GappedSequence(s):

  scala> val s1 = new DNA.GappedSequence("agc--taacg---")
  scala> val s2 = new DNA.GappedSequence("agc---aaca---")
  scala> val a = new Alignment(List(s1,s2))

== Using BioJAVA from Scala ==

One of the great features of Scala is that it runs on the JAVA virtual
machine and creates JAVA byte code. In effect, the generated byte code
is equal to that of JAVA generated byte code. This means you can
deploy Scala with JAVA, and you can interact between the two
languages. An example is in BioScala's Sequence translation, from
./src/main/scala/sequence/translate.scala

  import org.biojava.bio.symbol._
  import org.biojava.bio.seq._
  import bio._

  package bio {
    object SequenceTranslation {
      /** 
       * Translate nucleotides to amini acids (will change to returning List)
       */
      def translate(nucleotides: List[Nucleotide]): String = {
        val rna = RNATools.createRNA(nucleotides.mkString);
        val aa = RNATools.translate(rna);
        aa.seqString
      }
    }
  }

You can see we import BioJAVA classes, and call directly into
BioJAVA's RNATools to create an RNA object, followed by translation
to an amino acid string.

== Using BioRuby from Scala ==

BioRuby compiles against JRuby on the JAVA Virtual Machine. Like, the
description above, on BioJAVA, we can call directly into compiled Ruby byte
code. For a BioRuby translation example, create a Ruby class like:

  require 'java'
  require 'bio'

  class RbSequence
    def translate(sequence, frame, codon_table)
      seq = Bio::Sequence::NA.new(sequence)
      seq.translate(frame,codon_table)
    end
  end

After compiling above with jrubyc it can be invoked from Scala

  scala> val rbseq = new RbSequence
  scala> rbseq.translate("agtcat",1,1)

assuming you have the jruby-complete.jar file in the class path and BioRuby
installed.

== Further Reading ==

Giving a full description of BioScala is beyond the objective of this
tutorial. It is worthwhile checking the tests in the source tree -
these are written as specifications and self explanatory. See
the files in ./src/test/scala/bio. For example:

    "A DNA Sequence" should "allow multiple IDs" in {
      val s = new DNA.Sequence("ID456","Gene 456","agctaacg")
      val s2 = s.attrAdd(List(Id("GEO:456"),Id("Pubmed:456")))
      s2.idList === (List("ID456","Geo:456","Pubmed:456"))
    }

another source of documentation is the information presented by the
BioJAVA project. JAVA code maps easily to Scala, see the section on
BioJAVA in this document. 





